<?php

/**
 * MIT License
 * For full license information, please view the LICENSE file that was distributed with this source code.
 */

namespace Spryker\Sniffs\Commenting;

use Exception;
use PHP_CodeSniffer\Files\File;
use Spryker\Sniffs\AbstractSniffs\AbstractSprykerSniff;

/**
 * Checks if doc blocks of Spryker test classes contain all necessary @group annotations.
 */
class DocBlockTestGroupAnnotation2Sniff extends AbstractSprykerSniff
{
    /**
     * @var string
     */
    protected const ANNOTATION_START_TEXT = 'Auto-generated group annotations';

    /**
     * @var string
     */
    protected const ANNOTATION_END_TEXT = 'Add your own group annotations below this line';

    /**
     * @inheritDoc
     */
    public function register(): array
    {
        return [
            T_CLASS,
        ];
    }

    /**
     * @inheritDoc
     */
    public function process(File $phpCsFile, $stackPointer): void
    {
        $filename = $phpCsFile->getFilename();

        preg_match('#/(tests)/(SprykerTest|PyzTest)/(.+)(Test|Cest).php$#', $filename, $matches);
        if (!$matches) {
            return;
        }

        $namespaceParts = $this->getNamespaceParts($phpCsFile, $stackPointer);
        if (!$namespaceParts) {
            return;
        }

        $givenAnnotations = $this->getAnnotations($phpCsFile, $stackPointer);
        $expectedAnnotations = $this->getExpectedAnnotations($phpCsFile, $namespaceParts);

        if ($this->containsExpectedGroupAnnotations($givenAnnotations, $expectedAnnotations)) {
            return;
        }

        $endAutoGeneratedAnnotationsPosition = array_search(static::ANNOTATION_END_TEXT, $givenAnnotations, true);
        if ($endAutoGeneratedAnnotationsPosition && count($givenAnnotations) > count($expectedAnnotations)) {
            $additionalAnnotations = array_slice($givenAnnotations, $endAutoGeneratedAnnotationsPosition + 1);
            $expectedAnnotations = array_merge($expectedAnnotations, $additionalAnnotations);
        }

        $this->fixGroupAnnotation($phpCsFile, $stackPointer, $expectedAnnotations);
    }

    /**
     * @param \PHP_CodeSniffer\Files\File $phpCsFile
     * @param int $stackPointer
     * @param array<string> $expectedGroupAnnotations
     *
     * @return void
     */
    protected function fixGroupAnnotation(File $phpCsFile, int $stackPointer, array $expectedGroupAnnotations): void
    {
        $fix = $phpCsFile->addFixableError('@group annotation missing or incomplete', $stackPointer, 'Incomplete');

        if (!$fix) {
            return;
        }

        $docCommentEndPosition = $this->findRelatedDocBlock($phpCsFile, $stackPointer);

        if (!$docCommentEndPosition) {
            $this->addCommentWithGroupAnnotation($phpCsFile, $stackPointer, $expectedGroupAnnotations);

            return;
        }

        $this->modifyExistingComment($phpCsFile, $docCommentEndPosition, $expectedGroupAnnotations);
    }

    /**
     * @param \PHP_CodeSniffer\Files\File $phpCsFile
     * @param int $stackPointer
     * @param array<string> $expectedAnnotations
     *
     * @return void
     */
    protected function addCommentWithGroupAnnotation(
        File $phpCsFile,
        int $stackPointer,
        array $expectedAnnotations
    ): void {
        $tokens = $phpCsFile->getTokens();

        $startPosition = $stackPointer;
        while ($tokens[$startPosition - 1]['line'] === $tokens[$stackPointer]['line']) {
            $startPosition--;
        }

        $startPosition--;

        $phpCsFile->fixer->beginChangeset();

        $phpCsFile->fixer->addContent($startPosition, '/**');
        $phpCsFile->fixer->addNewline($startPosition);

        foreach ($expectedAnnotations as $annotation) {
            $phpCsFile->fixer->addContent($startPosition, ' * ' . $annotation);
            $phpCsFile->fixer->addNewline($startPosition);
        }

        $phpCsFile->fixer->addContent($startPosition, ' */');
        $phpCsFile->fixer->addNewline($startPosition);

        $phpCsFile->fixer->endChangeset();
    }

    /**
     * @param \PHP_CodeSniffer\Files\File $phpCsFile
     * @param int $docCommentEndPosition
     * @param array<string> $namespaceParts
     *
     * @return void
     */
    protected function modifyExistingComment(File $phpCsFile, int $docCommentEndPosition, array $namespaceParts): void
    {
        $tokens = $phpCsFile->getTokens();

        /** @var int $docCommentStartPosition */
        $docCommentStartPosition = $tokens[$docCommentEndPosition]['comment_opener'];

        $startPosition = $docCommentStartPosition + 2;

        $phpCsFile->fixer->beginChangeset();
        if ($startPosition) {
            $endPosition = $docCommentEndPosition - 2;
            for ($i = $startPosition; $i <= $endPosition; $i++) {
                $phpCsFile->fixer->replaceToken($i, '');
            }
        }

        foreach ($namespaceParts as $namespacePart) {
            $phpCsFile->fixer->addContent($startPosition, ' * ' . $namespacePart);
            $phpCsFile->fixer->addNewline($startPosition);
        }

        $phpCsFile->fixer->endChangeset();
    }

    /**
     * @param \PHP_CodeSniffer\Files\File $phpCsFile
     * @param int $stackPointer
     *
     * @return array<string>
     */
    protected function getNamespaceParts(File $phpCsFile, int $stackPointer): array
    {
        $namespace = $this->getNamespaceStatement($phpCsFile);
        if (!$namespace) {
            return [];
        }

        $parts = explode('\\', $namespace['namespace']);

        $name = $this->getClassOrInterfaceName($phpCsFile, $stackPointer);
        $parts[] = $name;

        return $parts;
    }

    /**
     * @param \PHP_CodeSniffer\Files\File $phpCsFile
     * @param int $stackPointer
     *
     * @return string
     */
    protected function getClassOrInterfaceName(File $phpCsFile, int $stackPointer): string
    {
        $classOrInterfacePosition = $phpCsFile->findPrevious([T_CLASS, T_INTERFACE], $stackPointer);

        if ($classOrInterfacePosition === false) {
            return '';
        }

        $classOrInterfaceNamePosition = $phpCsFile->findNext(T_STRING, $classOrInterfacePosition);

        return $phpCsFile->getTokens()[$classOrInterfaceNamePosition]['content'];
    }

    /**
     * @param \PHP_CodeSniffer\Files\File $phpCsFile
     * @param int $stackPointer
     *
     * @return array<int, string>
     */
    protected function getAnnotations(File $phpCsFile, int $stackPointer): array
    {
        $tokens = $phpCsFile->getTokens();

        $docBlockEndIndex = $this->findRelatedDocBlock($phpCsFile, $stackPointer);
        if (!$docBlockEndIndex) {
            return [];
        }

        $docBlockStartIndex = $tokens[$docBlockEndIndex]['comment_opener'];

        $parts = [];
        for ($i = $docBlockStartIndex; $i < $docBlockEndIndex; $i++) {
            $content = $tokens[$i]['content'];
            if ($content !== '@group' && $content !== static::ANNOTATION_START_TEXT && $content !== static::ANNOTATION_END_TEXT) {
                continue;
            }

            if ($content === '@group') {
                $i = $i + 2;
                $content = '@group ' . $tokens[$i]['content'];
            }

            $parts[] = $content;
        }

        return $parts;
    }

    /**
     * @param \PHP_CodeSniffer\Files\File $phpCsFile
     * @param array<string> $namespaceParts
     *
     * @return array<string>
     */
    protected function getExpectedAnnotations(File $phpCsFile, array $namespaceParts): array
    {
        $className = array_pop($namespaceParts);
        array_unshift($namespaceParts, static::ANNOTATION_START_TEXT);
        $expectedAnnotations = $namespaceParts;
        if ($className && preg_match('/Facade/', $className)) {
            array_push($expectedAnnotations, 'Facade');
        }
        array_push($expectedAnnotations, $className);
        array_push($expectedAnnotations, static::ANNOTATION_END_TEXT);

        $callback = function ($value) {
            if ($value === static::ANNOTATION_START_TEXT || $value === static::ANNOTATION_END_TEXT) {
                return $value;
            }

            return '@group ' . $value;
        };

        return array_map($callback, $expectedAnnotations);
    }

    /**
     * @param \PHP_CodeSniffer\Files\File $phpCsFile
     * @param int $docCommentStartPosition
     * @param int $firstDocCommentTagPosition
     *
     * @return int|null
     */
    protected function findGroupTagPosition(
        File $phpCsFile,
        int $docCommentStartPosition,
        int $firstDocCommentTagPosition
    ): ?int {
        $tokens = $phpCsFile->getTokens();
        $docEndIndex = $tokens[$docCommentStartPosition]['comment_closer'];

        for ($i = $firstDocCommentTagPosition; $i < $docEndIndex; $i++) {
            if ($tokens[$i]['content'] !== '@group') {
                continue;
            }

            while ($tokens[$i - 1]['line'] === $tokens[$i]['line']) {
                $i--;
            }

            return $i;
        }

        return null;
    }

    /**
     * @param \PHP_CodeSniffer\Files\File $phpCsFile
     * @param int $docCommentStartPosition
     *
     * @return int
     */
    protected function getLastLineOfDocBlock(File $phpCsFile, int $docCommentStartPosition): int
    {
        $tokens = $phpCsFile->getTokens();
        $index = $tokens[$docCommentStartPosition]['comment_closer'];

        while ($tokens[$index - 1]['line'] === $tokens[$index]['line']) {
            $index--;
        }

        return $index;
    }

    /**
     * @param \PHP_CodeSniffer\Files\File $phpCsFile
     * @param int $docCommentStartPosition
     * @param int $firstGroupTagPosition
     *
     * @throws \Exception
     *
     * @return int
     */
    protected function getGroupTagPositionEnd(
        File $phpCsFile,
        int $docCommentStartPosition,
        int $firstGroupTagPosition
    ): int {
        $tokens = $phpCsFile->getTokens();

        $docCommentCloserPosition = $tokens[$docCommentStartPosition]['comment_closer'];

        for ($i = $docCommentCloserPosition; $i > $firstGroupTagPosition; $i--) {
            if ($tokens[$i]['content'] !== '@group') {
                continue;
            }

            while ($tokens[$i + 1]['line'] === $tokens[$i]['line']) {
                $i++;
            }

            return $i;
        }

        throw new Exception('Not possible');
    }

    /**
     * @param array<string> $givenGroupAnnotationParts
     * @param array<string> $expectedGroupAnnotations
     *
     * @return bool
     */
    protected function containsExpectedGroupAnnotations(
        array $givenGroupAnnotationParts,
        array $expectedGroupAnnotations
    ): bool {
        if (count($givenGroupAnnotationParts) === 0) {
            return false;
        }
        foreach ($expectedGroupAnnotations as $index => $expectedGroupAnnotation) {
            if ($givenGroupAnnotationParts[$index] !== $expectedGroupAnnotation) {
                return false;
            }
        }

        return true;
    }
}
